.PHONY: install fmt lint test run build clean help dev-setup docker-up docker-down backup restore logs health
.PHONY: security-scan security-fast performance-test stress-test chaos-db chaos-redis resilience-test
.PHONY: analyze-performance analyze-chaos open-resilience-dashboard install-k6
.PHONY: k6-smoke
.PHONY: create-phase5-issues
.PHONY: preflight
.PHONY: canary-diff
.PHONY: validate-slo-compliance check-error-budget check-burn-rates create-incident-report validate-runbooks
.PHONY: test-incident-response generate-slo-report open-governance-docs compliance-dashboard pre-deploy-check
.PHONY: test-unit test-integration test-e2e test-business-metrics load-test chaos-test
.PHONY: security-deps security-deps-json security-deps-html install-security-tools
.PHONY: secret-scan secret-scan-json secret-scan-strict fix-permissions
.PHONY: owasp-scan owasp-scan-json owasp-scan-category owasp-report owasp-report-json
.PHONY: compliance-report compliance-report-json compliance-show
.PHONY: perf-smoke perf-load perf-stress perf-spike perf-soak perf-validate perf-baseline perf-clean
.PHONY: chaos-network chaos-service chaos-database chaos-pms chaos-resource chaos-all chaos-resilience
.PHONY: chaos-report chaos-monkey chaos-dry-run

HAS_UV := $(shell command -v uv >/dev/null 2>&1 && test -f pyproject.toml && echo 1 || echo 0)
HAS_UV_PROJECT := $(shell command -v uv >/dev/null 2>&1 && test -f pyproject.toml && grep -q '^\[project\]' pyproject.toml && echo 1 || echo 0)
HAS_POETRY := $(shell command -v poetry >/dev/null 2>&1 && test -f pyproject.toml && echo 1 || echo 0)
HAS_POETRY_PROJECT := $(shell test -f pyproject.toml && grep -q '^\[tool\.poetry\]' pyproject.toml && echo 1 || echo 0)
HAS_NPM := $(shell command -v npm >/dev/null 2>&1 && test -f package.json && echo 1 || echo 0)

# ==============================================================================
# Comandos Universales
# ==============================================================================

install: ## Instalar dependencias del proyecto
ifeq ($(HAS_UV_PROJECT),1)
	@echo "Installing dependencies with uv..."
	uv sync --all-extras

else ifeq ($(HAS_POETRY),1)
	@echo "Installing dependencies with poetry..."
	poetry install --all-extras --no-root
else ifeq ($(HAS_UV),1)
	@echo "uv est√° disponible pero pyproject no tiene secci√≥n [project]. Considera instalar poetry."
	@echo "Intentando instalar con uv igualmente..."
	uv sync --all-extras || true
else ifeq ($(HAS_NPM),1)
	@echo "Installing dependencies with npm..."
	npm install
else
	@echo "‚ùå No se detect√≥ gestor de dependencias (uv, poetry, npm)"
endif

fmt: ## Formatear todo el c√≥digo
	@echo "Formatting code..."
	ruff format .
	command -v prettier >/dev/null 2>&1 && prettier --write . --ignore-unknown || echo "(prettier no instalado)"

lint: ## Ejecutar linters y static analysis
	@echo "Running linters..."
	ruff check . --fix
	if test -f .gitleaks.toml; then \
		command -v gitleaks >/dev/null 2>&1 && gitleaks detect --no-git -v || echo "(gitleaks no instalado)"; \
	else \
		command -v gitleaks >/dev/null 2>&1 && gitleaks detect -v || echo "(gitleaks no instalado)"; \
	fi

security-fast: ## Escaneo r√°pido (solo HIGH/CRITICAL) con trivy fs (vuln + secrets)
	@echo "Security fast scan (HIGH/CRITICAL, vuln+secret)..."
	@if ! command -v trivy >/dev/null 2>&1; then echo "trivy no instalado"; exit 1; fi
	trivy fs --severity HIGH,CRITICAL --security-checks vuln,secret --quiet . || true

security-scan: ## Escaneo completo (deps, config, secretos, imagen) -> scripts/security-scan.sh
	@echo "Security full scan..."
	@bash scripts/security-scan.sh

security-deps: ## P011: Escaneo de vulnerabilidades en dependencias (CVE, licenses, outdated)
	@echo "üîê P011: Dependency Vulnerability Scan..."
	@python scripts/security/vulnerability_scan.py --format markdown --output .security/vuln-scan-latest.md
	@echo "‚úÖ Reporte generado: .security/vuln-scan-latest.md"

security-deps-json: ## P011: Escaneo de dependencias (output JSON)
	@echo "üîê P011: Dependency Vulnerability Scan (JSON)..."
	@python scripts/security/vulnerability_scan.py --format json --output .security/vuln-scan-latest.json
	@echo "‚úÖ Reporte generado: .security/vuln-scan-latest.json"

security-deps-html: ## P011: Escaneo de dependencias (output HTML)
	@echo "üîê P011: Dependency Vulnerability Scan (HTML)..."
	@python scripts/security/vulnerability_scan.py --format html --output .security/vuln-scan-latest.html
	@echo "‚úÖ Reporte generado: .security/vuln-scan-latest.html"
	@echo "Abrir con: xdg-open .security/vuln-scan-latest.html"

install-security-tools: ## Instalar herramientas de seguridad (pip-audit, safety, pip-licenses)
	@echo "üì¶ Instalando herramientas de seguridad..."
	pip install pip-audit safety pip-licenses
	@echo "‚úÖ Herramientas instaladas: pip-audit, safety, pip-licenses"

secret-scan: ## P012: Escaneo de secretos hardcodeados (output Markdown)
	@echo "üîç P012: Secret Scanning & Hardening..."
	@python scripts/security/secret_scanner.py --format markdown --output .security/secret-scan-latest.md
	@echo "‚úÖ Reporte generado: .security/secret-scan-latest.md"

secret-scan-json: ## P012: Escaneo de secretos (output JSON para CI/CD)
	@echo "üîç P012: Secret Scanning (JSON)..."
	@python scripts/security/secret_scanner.py --format json --output .security/secret-scan-latest.json
	@echo "‚úÖ Reporte generado: .security/secret-scan-latest.json"

secret-scan-strict: ## Escaneo estricto de secretos (falla en cualquier hallazgo)
	@echo "üîê Ejecutando escaneo estricto de secretos..."
	@mkdir -p .security
	@if [ ! -f scripts/security/secret_scanner.py ]; then \
		echo "‚ùå Error: scripts/security/secret_scanner.py no encontrado"; \
		exit 1; \
	fi
	@python3 scripts/security/secret_scanner.py --format markdown --strict || { \
		echo "‚ùå Escaneo estricto detect√≥ hallazgos"; \
		echo "Ver reporte en .security/secret-scan-latest.md"; \
		exit 1; \
	}
	@echo "‚úÖ Escaneo estricto completado sin hallazgos cr√≠ticos"

fix-permissions: ## Corregir permisos de archivos sensibles (auto-remediaci√≥n)
	@echo "ÔøΩ Corrigiendo permisos de archivos sensibles..."
	@if [ -f .env ]; then \
		chmod 600 .env && echo "‚úÖ .env permisos actualizados a 0600"; \
	fi
	@if [ -f .env.production ]; then \
		chmod 600 .env.production && echo "‚úÖ .env.production permisos actualizados a 0600"; \
	fi
	@find . -name "*.pem" -type f -exec chmod 600 {} + 2>/dev/null && echo "‚úÖ Archivos .pem actualizados" || echo "No .pem files found"
	@find . -name "*.key" -type f -exec chmod 600 {} + 2>/dev/null && echo "‚úÖ Archivos .key actualizados" || echo "No .key files found"
	@echo "‚úÖ Permisos corregidos"

# ------------------------------------------------------------------------------
# P013: OWASP Top 10 2021 Validation
# ------------------------------------------------------------------------------

owasp-scan: ## Escaneo completo OWASP Top 10 (Markdown)
	@echo "üõ°Ô∏è Ejecutando validaci√≥n OWASP Top 10 2021..."
	@mkdir -p .security
	@if [ ! -f scripts/security/owasp_validator.py ]; then \
		echo "‚ùå Error: scripts/security/owasp_validator.py no encontrado"; \
		exit 1; \
	fi
	@python3 scripts/security/owasp_validator.py --format markdown
	@echo "‚úÖ Escaneo completado. Ver reporte en .security/owasp-scan-latest.md"
	@echo "üìä Ejecuta 'make owasp-report' para ver el reporte"

owasp-scan-json: ## Escaneo OWASP Top 10 en formato JSON (CI/CD)
	@echo "üõ°Ô∏è Ejecutando validaci√≥n OWASP Top 10 (JSON)..."
	@mkdir -p .security
	@if [ ! -f scripts/security/owasp_validator.py ]; then \
		echo "‚ùå Error: scripts/security/owasp_validator.py no encontrado"; \
		exit 1; \
	fi
	@python3 scripts/security/owasp_validator.py --format json --output .security/owasp-scan-latest.json
	@echo "‚úÖ Escaneo JSON completado: .security/owasp-scan-latest.json"

owasp-scan-category: ## Escaneo de categor√≠a espec√≠fica OWASP (uso: make owasp-scan-category CATEGORY=A03)
	@echo "üõ°Ô∏è Escaneando categor√≠a OWASP $(CATEGORY)..."
	@if [ -z "$(CATEGORY)" ]; then \
		echo "‚ùå Error: Especifica CATEGORY (A01-A10)"; \
		echo "Ejemplo: make owasp-scan-category CATEGORY=A03"; \
		exit 1; \
	fi
	@mkdir -p .security
	@python3 scripts/security/owasp_validator.py --category $(CATEGORY) --format markdown
	@echo "‚úÖ Escaneo $(CATEGORY) completado"

owasp-report: ## Ver √∫ltimo reporte OWASP (Markdown)
	@if [ ! -f .security/owasp-scan-latest.md ]; then \
		echo "‚ùå No hay reporte disponible. Ejecuta 'make owasp-scan' primero"; \
		exit 1; \
	fi
	@cat .security/owasp-scan-latest.md

owasp-report-json: ## Ver √∫ltimo reporte OWASP (JSON formateado)
	@if [ ! -f .security/owasp-scan-latest.json ]; then \
		echo "‚ùå No hay reporte JSON disponible. Ejecuta 'make owasp-scan-json' primero"; \
		exit 1; \
	fi
	@cat .security/owasp-scan-latest.json | jq '.'

# ==============================================================================
# P014: Compliance Report (Consolidated)
# ==============================================================================

compliance-report: ## Generate consolidated compliance report (JSON + Markdown)
	@echo "üîê Generating compliance report (P014)..."
	@python3 scripts/security/compliance_report.py --format both
	@echo ""
	@echo "üìä Reports generated:"
	@echo "  - JSON: .security/compliance-report-latest.json"
	@echo "  - Markdown: .security/compliance-report-latest.md"
	@echo ""
	@echo "üí° View with: make compliance-show"

compliance-report-json: ## Generate compliance report (JSON only)
	@python3 scripts/security/compliance_report.py --format json

compliance-show: ## Display last compliance report (Markdown)
	@if [ -f .security/compliance-report-latest.md ]; then \
		cat .security/compliance-report-latest.md; \
	else \
		echo "‚ùå No compliance report found. Run 'make compliance-report' first."; \
		exit 1; \
	fi

# ==============================================================================
# File Security
# ==============================================================================

fix-permissions: ## P012: Corregir permisos de archivos sensibles
	@echo "üîí Fixing file permissions..."
	@chmod 600 .env .env.production 2>/dev/null || true
	@chmod 600 private_key.pem id_rsa id_ed25519 2>/dev/null || true
	@chmod 600 secrets.json credentials.json 2>/dev/null || true
	@echo "‚úÖ File permissions fixed (0600)"

test: ## Ejecutar tests con pytest (usa Poetry si est√° disponible)
ifeq ($(HAS_POETRY),1)
	poetry run pytest -q
else
	pytest -q
endif

test-unit: ## Ejecutar solo tests unitarios
ifeq ($(HAS_POETRY),1)
	poetry run pytest tests/unit/ -v
else
	pytest tests/unit/ -v
endif

test-integration: ## Ejecutar solo tests de integraci√≥n
ifeq ($(HAS_POETRY),1)
	poetry run pytest tests/integration/ -v
else
	pytest tests/integration/ -v
endif

test-e2e: ## Ejecutar solo tests end-to-end
ifeq ($(HAS_POETRY),1)
	poetry run pytest tests/e2e/ -v
else
	pytest tests/e2e/ -v
endif

test-business-metrics: ## Ejecutar tests de business metrics
ifeq ($(HAS_POETRY),1)
	poetry run pytest tests/unit/test_business_metrics.py -v
else
	pytest tests/unit/test_business_metrics.py -v
endif

load-test: ## Ejecutar load testing con Locust (requiere locust instalado)
	@echo "Starting Locust load test..."
	@if ! command -v locust >/dev/null 2>&1; then \
		echo "‚ùå Locust no instalado. Instalar con: pip install locust"; \
		exit 1; \
	fi
	@echo "Locust UI disponible en: http://localhost:8089"
	@echo "Configuraci√≥n sugerida: 50 usuarios, spawn rate 5, duraci√≥n 5m"
	locust -f tests/load/locustfile.py --host=http://localhost:8000

chaos-test: ## Ejecutar chaos engineering tests
ifeq ($(HAS_POETRY),1)
	@echo "Running chaos/resilience tests..."
	poetry run pytest tests/chaos/test_resilience.py -v --tb=short
else
	@echo "Running chaos/resilience tests..."
	pytest tests/chaos/test_resilience.py -v --tb=short
endif



# ==============================================================================
# Comandos Espec√≠ficos del Proyecto
# ==============================================================================

dev-setup: ## Configura el entorno de desarrollo inicial (copia .env)
	@echo "Configurando entorno de desarrollo..."
	if [ ! -f .env ]; then \
		cp .env.example .env; \
		echo "‚úÖ .env creado a partir de .env.example. Por favor, ed√≠talo con tus secretos."; \
	fi


docker-up: ## Levanta el stack de Docker en modo detached
	@echo "Levantando stack de Docker..."
	docker compose up -d --build


docker-down: ## Detiene y elimina los contenedores del stack
	@echo "Deteniendo stack de Docker..."
	docker compose down

backup: ## Ejecuta el script de backup
	@echo "Ejecutando backup..."
	bash scripts/backup.sh

restore: ## Ejecuta el script de restauraci√≥n
	@echo "Para restaurar, ejecuta: bash scripts/restore.sh <ruta_backup>"

logs: ## Muestra los logs de todos los servicios en tiempo real
	@echo "Mostrando logs..."
	docker compose logs -f

health: ## Ejecuta el script de health-check
	@echo "Verificando salud de los servicios..."
	bash scripts/health-check.sh

# ==============================================================================
# Utilidades de Monitorizaci√≥n
# ==============================================================================

monitoring-restart: ## Reinicia Prometheus, Grafana y Alertmanager
	@echo "Reiniciando stack de monitorizaci√≥n..."
	docker compose restart prometheus grafana alertmanager

alertmanager-logs: ## Muestra logs de Alertmanager
	@docker compose logs -f alertmanager

alertmanager-config: ## Muestra el config generado por entrypoint
	@docker exec -it agente_alertmanager sh -c 'cat /tmp/generated.yml || echo "generated.yml no disponible a√∫n"'

prometheus-rules-status: ## Muestra el estado de reglas cargadas en Prometheus (JSON)
	@docker exec -it agente_prometheus sh -c 'wget -qO- http://localhost:9090/api/v1/rules || echo "Prometheus no accesible"'

alertmanager-alerts: ## Lista alertas activas en Alertmanager (JSON)
	@docker exec -it agente_alertmanager sh -c 'wget -qO- http://localhost:9093/api/v2/alerts || echo "Alertmanager no accesible"'

prometheus-reload: ## Solicita recarga de configuraci√≥n de Prometheus (HTTP POST /-/reload)
	@docker exec -it agente_prometheus sh -c 'wget --spider --post-data="" -q http://localhost:9090/-/reload 2>/dev/null && echo "(reload enviado)" || echo "Prometheus no accesible"'

test-alert-429: ## Genera tr√°fico para provocar 429 en /webhooks/whatsapp
	@chmod +x scripts/generate_429.sh
	@HOST=localhost PORT=8000 REQUESTS=90 DELAY_MS=30 bash scripts/generate_429.sh

alerts-enable-test: ## Activa alerta sint√©tica (AlwaysFiring) en alerts-extra.yml
	@chmod +x scripts/alerts-enable-test.sh
	@bash scripts/alerts-enable-test.sh

alerts-disable-test: ## Desactiva alerta sint√©tica (restaura alerts-extra.yml)
	@chmod +x scripts/alerts-disable-test.sh
	@bash scripts/alerts-disable-test.sh

# ==============================================================================
# Hardening y Monitoreo Sint√©tico
# ==============================================================================

synthetic-health-check: ## Ejecuta health check sint√©tico (configurable via env vars)
	@chmod +x scripts/synthetic-health-check.sh
	@bash scripts/synthetic-health-check.sh

docker-vulnerability-scan: ## Escanea vulnerabilidades en imagen Docker actual
	@echo "Scanning Docker image for vulnerabilities..."
	@docker build -t agente-hotel-api:scan . >/dev/null 2>&1
	@trivy image --severity HIGH,CRITICAL agente-hotel-api:scan || echo "Vulnerabilities found - review output above"

docker-build-hardened: ## Build imagen con hardening y health checks
	@echo "Building hardened Docker image..."
	@docker build -t agente-hotel-api:hardened .
	@echo "Testing health check..."
	@timeout 30s docker run --rm -d -p 8002:8000 -e DEBUG=true -e ENVIRONMENT=development -e SECRET_KEY=test-key agente-hotel-api:hardened || true
	@sleep 5
	@HEALTH_CHECK_URL=http://localhost:8002 TIMEOUT=5 MAX_RETRIES=1 bash scripts/synthetic-health-check.sh || true
	@docker stop $$(docker ps -q --filter ancestor=agente-hotel-api:hardened) 2>/dev/null || true

validate-guardrails: ## Valida que todos los guardrails est√©n configurados correctamente
	@echo "üõ°Ô∏è Validating guardrails configuration..."
	@echo "Checking guardrails.conf..."
	@test -f scripts/guardrails.conf && echo "‚úÖ Guardrails config exists" || { echo "‚ùå Guardrails config missing"; exit 1; }
	@echo "Checking Dependabot limits..."
	@grep -q "open-pull-requests-limit: [1-5]" ../.github/dependabot.yml && echo "‚úÖ Dependabot PR limits OK" || echo "‚ö†Ô∏è Check Dependabot limits"
	@echo "Checking workflow timeouts..."
	@grep -q "timeout-minutes:" ../.github/workflows/ci.yml && echo "‚úÖ CI timeouts configured" || echo "‚ö†Ô∏è Missing CI timeouts"
	@grep -q "timeout-minutes:" ../.github/workflows/nightly-security.yml && echo "‚úÖ Nightly timeouts configured" || echo "‚ö†Ô∏è Missing nightly timeouts"
	@echo "Checking synthetic health check limits..."
	@grep -q "ABSOLUTE_MAX_RETRIES" scripts/synthetic-health-check.sh && echo "‚úÖ Health check limits OK" || echo "‚ö†Ô∏è Missing health check limits"
	@echo "üéØ Guardrails validation complete!"

test-circuit-breakers: ## Prueba los circuit breakers con cargas controladas
	@echo "üîÑ Testing circuit breakers..."
	@echo "Testing health check rate limiting..."
	@for i in {1..3}; do \
		echo "Attempt $$i:"; \
		TIMEOUT=2 MAX_RETRIES=1 bash scripts/synthetic-health-check.sh || true; \
		sleep 1; \
	done
	@echo "Circuit breaker test complete!"

# ==============================================================================
# Performance & Chaos Engineering
# ==============================================================================

performance-test: ## Ejecuta pruebas de rendimiento con k6
k6-smoke: ## Ejecuta smoke test r√°pido (60s, validar P95 y error rate)
create-phase5-issues: ## Crea issues est√°ndar de la Fase 5 (requiere gh auth)
	@echo "üìå Creando issues Fase 5..."
	@bash scripts/create-phase5-issues.sh || echo "‚ö† Revisa autenticaci√≥n gh"
	@echo "‚úÖ Proceso finalizado"
	@echo "üöÄ Running k6 smoke test..."
	@command -v k6 >/dev/null 2>&1 || { echo "‚ùå k6 not found. Ejecuta 'make install-k6'"; exit 1; }
	@mkdir -p reports/performance
	@K6_DURATION=$${K6_DURATION:-60s} K6_RPS=$${K6_RPS:-50} k6 run tests/performance/smoke-test.js || true
	@bash scripts/eval-smoke.sh || echo "‚ö† Gating fall√≥ (ver arriba)"
	@echo "(Gating local no bloqueante)"
	@echo "üöÄ Running performance tests..."
	@command -v k6 >/dev/null 2>&1 || { echo "‚ùå k6 not found. Install with: curl https://github.com/grafana/k6/releases/download/v0.46.0/k6-v0.46.0-linux-amd64.tar.gz | tar -xz && sudo cp k6-v0.46.0-linux-amd64/k6 /usr/local/bin/"; exit 1; }
	@mkdir -p reports/performance
	k6 run tests/performance/load-test.js
	@echo "‚úÖ Performance test complete"

stress-test: ## Ejecuta pruebas de estr√©s para encontrar puntos de ruptura
	@echo "üí• Running stress tests..."
	@command -v k6 >/dev/null 2>&1 || { echo "‚ùå k6 not found. Install with: curl https://github.com/grafana/k6/releases/download/v0.46.0/k6-v0.46.0-linux-amd64.tar.gz | tar -xz && sudo cp k6-v0.46.0-linux-amd64/k6 /usr/local/bin/"; exit 1; }
	@mkdir -p reports/performance
	k6 run tests/performance/stress-test.js
	@echo "‚úÖ Stress test complete"

chaos-db: ## Simula fallas de base de datos
	@echo "üóÑÔ∏è Running database chaos test..."
	@chmod +x scripts/chaos-db-failure.sh
	@bash scripts/chaos-db-failure.sh
	@echo "‚úÖ Database chaos test complete"

chaos-redis: ## Simula fallas de Redis/cache
	@echo "üîÑ Running Redis chaos test..."
	@chmod +x scripts/chaos-redis-failure.sh
	@bash scripts/chaos-redis-failure.sh
	@echo "‚úÖ Redis chaos test complete"

resilience-test: ## Suite completa de pruebas de resiliencia (performance + chaos)
	@echo "üß™ Running comprehensive resilience test suite..."
	@chmod +x scripts/resilience-test-suite.sh
	@bash scripts/resilience-test-suite.sh
	@echo "‚úÖ Resilience test suite complete"

analyze-performance: ## Analiza resultados de pruebas de rendimiento
	@echo "üìä Analyzing performance results..."
	@if [ -z "$(REPORT)" ]; then echo "Usage: make analyze-performance REPORT=<timestamp>"; exit 1; fi
	@if [ -f "reports/resilience/load-test-summary-$(REPORT).json" ]; then \
		echo "üìà Load Test Summary:"; \
		cat reports/resilience/load-test-summary-$(REPORT).json | jq '.metrics' 2>/dev/null || cat reports/resilience/load-test-summary-$(REPORT).json; \
	fi
	@if [ -f "reports/resilience/stress-test-summary-$(REPORT).json" ]; then \
		echo "üí• Stress Test Summary:"; \
		cat reports/resilience/stress-test-summary-$(REPORT).json | jq '.metrics' 2>/dev/null || cat reports/resilience/stress-test-summary-$(REPORT).json; \
	fi

analyze-chaos: ## Analiza resultados de pruebas de chaos engineering
	@echo "üå™Ô∏è Analyzing chaos results..."
	@if [ -z "$(REPORT)" ]; then echo "Usage: make analyze-chaos REPORT=<timestamp>"; exit 1; fi
	@if [ -f "reports/resilience/chaos-db-$(REPORT).log" ]; then \
		echo "üóÑÔ∏è Database Chaos Summary:"; \
		grep -E "(Started|Recovery detected|Total downtime)" reports/resilience/chaos-db-$(REPORT).log | tail -5; \
	fi
	@if [ -f "reports/resilience/chaos-redis-$(REPORT).log" ]; then \
		echo "üîÑ Redis Chaos Summary:"; \
		grep -E "(Started|Recovery detected|Total downtime)" reports/resilience/chaos-redis-$(REPORT).log | tail -5; \
	fi

open-resilience-dashboard: ## Abre el dashboard de resiliencia en Grafana
	@echo "üìä Opening resilience dashboard..."
	@echo "URL: http://localhost:3000/d/resilience-chaos/resilience-chaos-engineering-dashboard"
	@command -v xdg-open >/dev/null 2>&1 && xdg-open "http://localhost:3000/d/resilience-chaos/resilience-chaos-engineering-dashboard" || echo "Open manually in browser"

install-k6: ## Instala k6 para pruebas de rendimiento
	@echo "üì¶ Installing k6..."
	@if command -v k6 >/dev/null 2>&1; then echo "‚úÖ k6 already installed"; else \
		curl -L https://github.com/grafana/k6/releases/download/v0.46.0/k6-v0.46.0-linux-amd64.tar.gz | tar -xz && \
		sudo cp k6-v0.46.0-linux-amd64/k6 /usr/local/bin/ && \
		rm -rf k6-v0.46.0-linux-amd64 && \
		echo "‚úÖ k6 installed successfully"; \
	fi

# ==============================================================================
# Governance & SLO Management
# ==============================================================================

validate-slo-compliance: ## Valida cumplimiento de SLOs en tiempo real
	@echo "üéØ Validating SLO compliance..."
	@chmod +x scripts/validate-slo-compliance.sh
	@bash scripts/validate-slo-compliance.sh
	@echo "‚úÖ SLO validation complete"

check-error-budget: ## Verifica consumo de error budget
	@echo "üìä Checking error budget consumption..."
	@curl -s "http://localhost:9090/api/v1/query?query=orchestrator_error_budget_used_ratio_30m*100" | \
		jq -r '.data.result[0].value[1] // "No data"' | \
		awk '{printf "Error Budget Used: %.2f%%\n", $$1}'

check-burn-rates: ## Verifica burn rates de SLOs
	@echo "üî• Checking SLO burn rates..."
	@echo "Fast burn rate (5m):"
	@curl -s "http://localhost:9090/api/v1/query?query=orchestrator_burn_rate_fast" | \
		jq -r '.data.result[0].value[1] // "No data"' | \
		awk '{printf "  %.2f (alert if > 2.0)\n", $$1}'
	@echo "Slow burn rate (1h):"
	@curl -s "http://localhost:9090/api/v1/query?query=orchestrator_burn_rate_slow" | \
		jq -r '.data.result[0].value[1] // "No data"' | \
		awk '{printf "  %.2f (alert if > 1.5)\n", $$1}'

create-incident-report: ## Crea un nuevo reporte de incidente
	@echo "üìù Creating incident report..."
	@if [ -z "$(INCIDENT)" ]; then echo "Usage: make create-incident-report INCIDENT=description"; exit 1; fi
	@mkdir -p reports/incidents
	@TIMESTAMP=$$(date +%Y%m%d_%H%M%S) && \
		cp docs/templates/post-mortem-template.md "reports/incidents/incident-$$TIMESTAMP-$(INCIDENT).md" && \
		echo "üìÑ Created: reports/incidents/incident-$$TIMESTAMP-$(INCIDENT).md"

validate-runbooks: ## Valida que todos los runbooks est√©n actualizados
	@echo "üìö Validating runbooks..."
	@find docs/runbooks -name "*.md" -type f | while read -r runbook; do \
		if grep -q "Last Updated.*\$$(date)" "$$runbook"; then \
			echo "‚úÖ $$runbook: Up to date"; \
		else \
			echo "‚ö†Ô∏è $$runbook: Needs update"; \
		fi; \
	done

test-incident-response: ## Prueba los procedimientos de respuesta a incidentes
	@echo "üö® Testing incident response procedures..."
	@echo "Testing alert acknowledgment..."
	@echo "Testing escalation contacts..."
	@echo "Testing runbook accessibility..."
	@echo "‚úÖ Incident response test complete"

generate-slo-report: ## Genera reporte detallado de SLOs
	@echo "üìà Generating SLO report..."
	@mkdir -p reports/slo
	@TIMESTAMP=$$(date +%Y%m%d_%H%M%S) && \
		bash scripts/validate-slo-compliance.sh > "reports/slo/slo-report-$$TIMESTAMP.txt" 2>&1 && \
		echo "üìÑ Report generated: reports/slo/slo-report-$$TIMESTAMP.txt"

open-governance-docs: ## Abre la documentaci√≥n de governance
	@echo "üìñ Opening governance documentation..."
	@echo "Available documents:"
	@echo "  - docs/GOVERNANCE_FRAMEWORK.md"
	@find docs/runbooks -name "*.md" -exec echo "  - {}" \;
	@command -v xdg-open >/dev/null 2>&1 && xdg-open docs/GOVERNANCE_FRAMEWORK.md || echo "Open docs/GOVERNANCE_FRAMEWORK.md manually"

compliance-dashboard: ## Abre dashboard de compliance en Grafana
	@echo "üìä Opening compliance dashboard..."
	@echo "URL: http://localhost:3000/d/compliance/compliance-dashboard"
	@command -v xdg-open >/dev/null 2>&1 && xdg-open "http://localhost:3000/d/compliance/compliance-dashboard" || echo "Open manually in browser"

pre-deploy-check: ## Validaci√≥n completa pre-deployment
	@echo "üöÄ Running pre-deployment validation..."
	@echo "1. Running tests..."
	@make test || { echo "‚ùå Tests failed"; exit 1; }
	@echo "2. Security scan..."
	@make security-fast || { echo "‚ùå Security scan failed"; exit 1; }
	@echo "3. SLO compliance check..."
	@make validate-slo-compliance || { echo "‚ùå SLO compliance failed"; exit 1; }
	@echo "4. Validating guardrails..."
	@make validate-guardrails || { echo "‚ùå Guardrails validation failed"; exit 1; }
	@echo "‚úÖ Pre-deployment validation complete"

# ==============================================================================
# Deployment & Production Operations
# ==============================================================================

validate-deployment: ## Ejecuta validaci√≥n completa pre-deployment
	@echo "üîç Running comprehensive pre-deployment validation..."
	@chmod +x scripts/pre-deployment-validation.sh
	@bash scripts/pre-deployment-validation.sh

deploy-production: ## Despliegue a producci√≥n con validaciones
	@echo "üöÄ Starting production deployment..."
	@make validate-deployment || { echo "‚ùå Pre-deployment validation failed"; exit 1; }
	@echo "Pre-deployment validation passed. Proceeding with deployment..."
	@chmod +x scripts/deploy.sh
	@bash scripts/deploy.sh production

deploy-staging: ## Despliegue a staging para pruebas
	@echo "üß™ Starting staging deployment..."
	@chmod +x scripts/deploy.sh
	@bash scripts/deploy.sh staging

build-production: ## Construye imagen de producci√≥n
	@echo "üî® Building production image..."
	@docker build -f Dockerfile.production -t agente-hotel-api:production .
	@echo "‚úÖ Production image built successfully"

test-production-image: ## Prueba la imagen de producci√≥n localmente
	@echo "üß™ Testing production image..."
	@docker run --rm -d --name agente-test -p 8080:8000 agente-hotel-api:production
	@sleep 10
	@curl -f http://localhost:8080/health/live || { docker stop agente-test; echo "‚ùå Health check failed"; exit 1; }
	@docker stop agente-test
	@echo "‚úÖ Production image test passed"

canary-deploy: ## Realiza despliegue canary
	@echo "üê§ Starting canary deployment..."
	@chmod +x scripts/canary-deploy.sh
	@bash scripts/canary-deploy.sh

deployment-status: ## Verifica estado del despliegue actual
	@echo "üìä Checking deployment status..."
	@echo "=== Docker Services ==="
	@docker compose -f docker-compose.production.yml ps || echo "Production stack not running"
	@echo "=== Health Checks ==="
	@curl -s http://localhost:8000/health/ready | jq . || echo "API not responding"
	@echo "=== Recent Logs ==="
	@docker compose -f docker-compose.production.yml logs --tail=10 agente-api || echo "No logs available"

help: ## Muestra esta ayuda
	@awk 'BEGIN {FS = ":.*##"}; /^[a-zA-Z0-9_\-]+:.*?##/ {printf "\033[36m%-24s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST)

preflight: ## Ejecuta preflight (calcula risk_score y genera reporte)
	@echo "üö¶ Ejecutando preflight..."

canary-diff: ## Ejecuta canary deploy local y genera .playbook/canary_diff_report.json
	@echo "üü° Ejecutando canary diff (baseline vs canary)"
	@bash scripts/canary-deploy.sh --dry-run || true
	@bash scripts/canary-deploy.sh staging local || true
	@test -f .playbook/canary_diff_report.json && echo "Reporte: .playbook/canary_diff_report.json" || echo "Sin reporte"
	@command -v python3 >/dev/null 2>&1 || { echo "Python3 no disponible"; exit 1; }
	@python3 -c "import yaml" 2>/dev/null || { echo "Instalando pyyaml (sudo puede ser requerido)"; python3 -m pip install --user pyyaml >/dev/null; }
	@python3 scripts/preflight.py || exit $$?
	@python3 scripts/validate_preflight.py || exit $$?
	@echo "‚úÖ Preflight completado"

# ==============================================================================
# Development Experience Commands
# ==============================================================================

dev-up: ## Levanta stack de desarrollo con hot-reload
	@echo "üöÄ Levantando entorno de desarrollo..."
	docker compose -f docker-compose.dev.yml up -d
	@echo "‚úÖ Servicios levantados"
	@echo "   API:     http://localhost:8000"
	@echo "   Docs:    http://localhost:8000/docs"
	@echo "   Logs:    make dev-logs"

dev-down: ## Detiene stack de desarrollo
	@echo "üõë Deteniendo entorno de desarrollo..."
	docker compose -f docker-compose.dev.yml down

dev-logs: ## Muestra logs del entorno de desarrollo
	docker compose -f docker-compose.dev.yml logs -f

dev-restart: ## Reinicia el servicio de API en desarrollo
	@echo "üîÑ Reiniciando API..."
	docker compose -f docker-compose.dev.yml restart agente-api

dev-shell: ## Abre shell en el contenedor de desarrollo
	docker compose -f docker-compose.dev.yml exec agente-api /bin/bash

dev-db-admin: ## Levanta herramientas de admin de BD (Adminer + Redis Commander)
	@echo "üóÑÔ∏è  Levantando herramientas de admin..."
	docker compose -f docker-compose.dev.yml --profile db-admin up -d
	@echo "‚úÖ Admin tools levantadas"
	@echo "   Adminer (PostgreSQL): http://localhost:8080"
	@echo "   Redis Commander:      http://localhost:8081"

dev-monitoring: ## Levanta stack de monitoring (Prometheus + Grafana)
	@echo "üìä Levantando monitoring stack..."
	docker compose -f docker-compose.dev.yml --profile monitoring up -d
	@echo "‚úÖ Monitoring levantado"
	@echo "   Prometheus: http://localhost:9090"
	@echo "   Grafana:    http://localhost:3000 (admin/admin)"

dev-full: ## Levanta stack completo (dev + monitoring + admin)
	@echo "üöÄ Levantando stack completo de desarrollo..."
	docker compose -f docker-compose.dev.yml --profile full up -d
	@echo "‚úÖ Stack completo levantado"
	@make dev-status

dev-status: ## Muestra el estado de los servicios de desarrollo
	@echo "üìã Estado de servicios:"
	@docker compose -f docker-compose.dev.yml ps

dev-clean: ## Limpia volumes y cache de desarrollo
	@echo "üßπ Limpiando datos de desarrollo..."
	docker compose -f docker-compose.dev.yml down -v
	@echo "‚úÖ Limpieza completada"

test-cov: ## Ejecutar tests con coverage report
	@echo "üß™ Ejecutando tests con coverage..."
ifeq ($(HAS_POETRY),1)
	poetry run pytest --cov=app --cov-report=html --cov-report=term-missing
else
	pytest --cov=app --cov-report=html --cov-report=term-missing
endif
	@echo "üìä Coverage report: htmlcov/index.html"

test-watch: ## Ejecutar tests en modo watch (auto-reload)
	@echo "üëÄ Ejecutando tests en modo watch..."
ifeq ($(HAS_POETRY),1)
	poetry run ptw -- -v
else
	ptw -- -v
endif

test-unit: ## Ejecutar solo tests unitarios
	@echo "üß™ Ejecutando tests unitarios..."
ifeq ($(HAS_POETRY),1)
	poetry run pytest tests/unit -v
else
	pytest tests/unit -v
endif

test-integration: ## Ejecutar solo tests de integraci√≥n
	@echo "üîó Ejecutando tests de integraci√≥n..."
ifeq ($(HAS_POETRY),1)
	poetry run pytest tests/integration -v
else
	pytest tests/integration -v
endif

test-e2e: ## Ejecutar tests end-to-end
	@echo "üåê Ejecutando tests E2E..."
ifeq ($(HAS_POETRY),1)
	poetry run pytest tests/e2e -v
else
	pytest tests/e2e -v
endif

test-debug: ## Ejecutar tests con debugging habilitado
	@echo "üêõ Ejecutando tests en modo debug..."
ifeq ($(HAS_POETRY),1)
	poetry run pytest -vv -s --pdb
else
	pytest -vv -s --pdb
endif

benchmark: ## Ejecutar benchmarks de performance
	@echo "‚ö° Ejecutando benchmarks..."
ifeq ($(HAS_POETRY),1)
	poetry run pytest tests/ --benchmark-only --benchmark-autosave
else
	pytest tests/ --benchmark-only --benchmark-autosave
endif

quick-check: ## Validaci√≥n r√°pida (lint + test unit + security-fast)
	@echo "‚ö° Quick check..."
	@make lint
	@make test-unit
	@make security-fast
	@echo "‚úÖ Quick check completado"

full-check: ## Validaci√≥n completa (lint + test + coverage + security)
	@echo "üîç Full check..."
	@make lint
	@make test-cov
	@make security-fast
	@echo "‚úÖ Full check completado"

##@ Advanced Tools (Phase B)

.PHONY: pre-commit-install pre-commit-run pre-commit-update security-scan type-check ci-local benchmark-baseline benchmark-compare update-operational-metrics

pre-commit-install: ## Instalar pre-commit hooks
	@echo "ü™ù Instalando pre-commit hooks..."
	@if command -v poetry >/dev/null 2>&1; then \
		poetry run pre-commit install; \
	else \
		pre-commit install; \
	fi
	@echo "‚úÖ Pre-commit hooks instalados"

pre-commit-run: ## Ejecutar pre-commit en todos los archivos
	@echo "üîç Ejecutando pre-commit en todos los archivos..."
	@if command -v poetry >/dev/null 2>&1; then \
		poetry run pre-commit run --all-files; \
	else \
		pre-commit run --all-files; \
	fi

pre-commit-update: ## Actualizar versiones de pre-commit hooks
	@echo "‚¨ÜÔ∏è Actualizando pre-commit hooks..."
	@if command -v poetry >/dev/null 2>&1; then \
		poetry run pre-commit autoupdate; \
	else \
		pre-commit autoupdate; \
	fi
	@echo "‚úÖ Pre-commit hooks actualizados"

security-scan: ## Ejecutar Bandit (security scan) en el c√≥digo
	@echo "üîí Ejecutando an√°lisis de seguridad con Bandit..."
	@if command -v poetry >/dev/null 2>&1; then \
		poetry run bandit -c pyproject.toml -r app/; \
	else \
		bandit -c pyproject.toml -r app/; \
	fi

type-check: ## Ejecutar MyPy (type checking) en el c√≥digo
	@echo "üîé Ejecutando type checking con MyPy..."
	@if command -v poetry >/dev/null 2>&1; then \
		poetry run mypy app/ --config-file=pyproject.toml; \
	else \
		mypy app/ --config-file=pyproject.toml; \
	fi

ci-local: ## Ejecutar pipeline CI completo (requiere Docker running)
	@echo "üöÄ Ejecutando CI local pipeline..."
	@if [ ! -f scripts/ci-local.sh ]; then \
		echo "‚ùå Error: scripts/ci-local.sh no encontrado"; \
		exit 1; \
	fi
	@bash scripts/ci-local.sh

benchmark-baseline: ## Crear baseline de benchmarks
	@echo "üìä Creando baseline de benchmarks..."
	@mkdir -p .benchmarks
	@if command -v poetry >/dev/null 2>&1; then \
		poetry run pytest tests/benchmarks/ --benchmark-only --benchmark-json=.benchmarks/baseline.json; \
	else \
		pytest tests/benchmarks/ --benchmark-only --benchmark-json=.benchmarks/baseline.json; \
	fi
	@echo "‚úÖ Baseline creado en .benchmarks/baseline.json"

benchmark-compare: ## Comparar benchmarks actuales con baseline
	@echo "üìà Comparando benchmarks..."
	@if [ ! -f scripts/benchmark-compare.sh ]; then \
		echo "‚ùå Error: scripts/benchmark-compare.sh no encontrado"; \
		exit 1; \
	fi
	@bash scripts/benchmark-compare.sh

update-operational-metrics: ## Actualizar m√©tricas operacionales del hotel (occupancy, ADR, RevPAR)
	@echo "üè® Actualizando m√©tricas operacionales..."
	@if [ ! -f scripts/update_operational_metrics.py ]; then \
		echo "‚ùå Error: scripts/update_operational_metrics.py no encontrado"; \
		exit 1; \
	fi
	@poetry run python scripts/update_operational_metrics.py

# ==============================================================================
# Performance Testing (P015)
# ==============================================================================

perf-smoke: ## Run smoke test (1 VU, 1 min) - quick validation
	@echo "üö¨ Running smoke test..."
	@mkdir -p .performance
	@k6 run --env SCENARIO=smoke \
		--env BASE_URL=http://localhost:8000 \
		--out json=.performance/results-smoke-$$(date +%Y%m%d-%H%M%S).json \
		tests/load/k6-performance-suite.js
	@echo "‚úÖ Smoke test complete. Run 'make perf-validate' to check SLOs."

perf-load: ## Run load test (10 VUs, 14 min) - validate SLOs
	@echo "üìä Running load test..."
	@mkdir -p .performance
	@k6 run --env SCENARIO=load \
		--env BASE_URL=http://localhost:8000 \
		--out json=.performance/results-load-$$(date +%Y%m%d-%H%M%S).json \
		tests/load/k6-performance-suite.js
	@echo "‚úÖ Load test complete. Run 'make perf-validate' to check SLOs."

perf-stress: ## Run stress test (up to 50 VUs, 27 min) - find breaking point
	@echo "üí™ Running stress test..."
	@mkdir -p .performance
	@k6 run --env SCENARIO=stress \
		--env BASE_URL=http://localhost:8000 \
		--out json=.performance/results-stress-$$(date +%Y%m%d-%H%M%S).json \
		tests/load/k6-performance-suite.js
	@echo "‚úÖ Stress test complete. Run 'make perf-validate' to check results."

perf-spike: ## Run spike test (0‚Üí100‚Üí0 VUs, 4 min) - test resilience
	@echo "‚ö° Running spike test..."
	@mkdir -p .performance
	@k6 run --env SCENARIO=spike \
		--env BASE_URL=http://localhost:8000 \
		--out json=.performance/results-spike-$$(date +%Y%m%d-%H%M%S).json \
		tests/load/k6-performance-suite.js
	@echo "‚úÖ Spike test complete. Check if rate limiting activated."

perf-soak: ## Run soak test (5 VUs, 30 min) - detect memory leaks
	@echo "üõÅ Running soak test..."
	@mkdir -p .performance
	@k6 run --env SCENARIO=soak \
		--env BASE_URL=http://localhost:8000 \
		--out json=.performance/results-soak-$$(date +%Y%m%d-%H%M%S).json \
		tests/load/k6-performance-suite.js
	@echo "‚úÖ Soak test complete. Monitor memory usage trends."

perf-validate: ## Validate latest performance test results against SLOs
	@echo "üéØ Validating performance results..."
	@if [ ! -f tests/load/validate_performance.py ]; then \
		echo "‚ùå Error: tests/load/validate_performance.py not found"; \
		exit 1; \
	fi
	@chmod +x tests/load/validate_performance.py
	@python3 tests/load/validate_performance.py

perf-baseline: ## Establish performance baseline
	@echo "üìà Establishing performance baseline..."
	@mkdir -p .performance
	@echo "Running smoke test..."
	@k6 run --env SCENARIO=smoke \
		--env BASE_URL=http://localhost:8000 \
		--out json=.performance/baseline-smoke.json \
		tests/load/k6-performance-suite.js
	@echo "Running load test..."
	@k6 run --env SCENARIO=load \
		--env BASE_URL=http://localhost:8000 \
		--out json=.performance/baseline-load.json \
		tests/load/k6-performance-suite.js
	@echo "Validating baselines..."
	@python3 tests/load/validate_performance.py --results .performance/baseline-load.json \
		--format markdown --output .performance/baseline-report.md
	@echo "‚úÖ Baseline established. Results in .performance/baseline-report.md"

perf-clean: ## Clean performance test results
	@echo "üßπ Cleaning performance results..."
	@rm -rf .performance/*.json .performance/*.html .performance/*.md
	@echo "‚úÖ Performance results cleaned"

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# OBSERVABILITY TARGETS (P016)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

obs-up: ## Start observability stack (Prometheus, Grafana, Jaeger, AlertManager)
	@echo "üî≠ Starting observability stack..."
	@docker compose up -d prometheus grafana jaeger alertmanager
	@echo "‚úÖ Observability stack started"
	@echo "üìä Prometheus: http://localhost:9090"
	@echo "üìà Grafana: http://localhost:3000 (admin/admin)"
	@echo "üîç Jaeger: http://localhost:16686"
	@echo "üö® AlertManager: http://localhost:9093"

obs-down: ## Stop observability stack
	@echo "üõë Stopping observability stack..."
	@docker compose stop prometheus grafana jaeger alertmanager
	@echo "‚úÖ Observability stack stopped"

obs-prometheus: ## Open Prometheus UI in browser
	@echo "üìä Opening Prometheus..."
	@xdg-open http://localhost:9090 2>/dev/null || open http://localhost:9090 2>/dev/null || echo "Open http://localhost:9090 in your browser"

obs-grafana: ## Open Grafana UI in browser
	@echo "üìà Opening Grafana..."
	@xdg-open http://localhost:3000 2>/dev/null || open http://localhost:3000 2>/dev/null || echo "Open http://localhost:3000 in your browser (admin/admin)"

obs-jaeger: ## Open Jaeger UI in browser
	@echo "üîç Opening Jaeger..."
	@xdg-open http://localhost:16686 2>/dev/null || open http://localhost:16686 2>/dev/null || echo "Open http://localhost:16686 in your browser"

obs-health: ## Check health of observability services
	@echo "üîç Checking observability stack health..."
	@echo "Prometheus:"
	@curl -sf http://localhost:9090/-/healthy > /dev/null && echo "  ‚úÖ Healthy" || echo "  ‚ùå Unhealthy"
	@echo "Grafana:"
	@curl -sf http://localhost:3000/api/health > /dev/null && echo "  ‚úÖ Healthy" || echo "  ‚ùå Unhealthy"
	@echo "Jaeger:"
	@curl -sf http://localhost:14269/ > /dev/null && echo "  ‚úÖ Healthy" || echo "  ‚ùå Unhealthy"
	@echo "AlertManager:"
	@curl -sf http://localhost:9093/-/healthy > /dev/null && echo "  ‚úÖ Healthy" || echo "  ‚ùå Unhealthy"

obs-logs: ## Follow logs of observability services
	@docker compose logs -f prometheus grafana jaeger alertmanager

obs-restart: ## Restart observability stack
	@echo "üîÑ Restarting observability stack..."
	@docker compose restart prometheus grafana jaeger alertmanager
	@echo "‚úÖ Observability stack restarted"

# ==============================================================================
# Chaos Engineering
# ==============================================================================

chaos-network: ## Run network chaos scenarios (latency, timeouts, failures)
	@echo "üå™Ô∏è  Running network chaos scenarios..."
	@poetry run pytest tests/chaos/scenarios/test_network.py -v || \
	 poetry run python -m pytest tests/chaos/test_advanced_resilience.py::TestMTTRMetrics::test_network_latency_mttr -v
	@echo "‚úÖ Network chaos scenarios completed"

chaos-service: ## Run service chaos scenarios (failures, circuit breakers, rate limits)
	@echo "üå™Ô∏è  Running service chaos scenarios..."
	@poetry run pytest tests/chaos/scenarios/test_service.py -v || \
	 poetry run python -m pytest tests/chaos/test_advanced_resilience.py::TestCircuitBreakerTransitions -v
	@echo "‚úÖ Service chaos scenarios completed"

chaos-database: ## Run database chaos scenarios (connection failures, slow queries)
	@echo "üå™Ô∏è  Running database chaos scenarios..."
	@poetry run pytest tests/chaos/scenarios/test_database.py -v || \
	 poetry run python -m pytest tests/chaos/test_advanced_resilience.py::TestMTTRMetrics::test_mttr_pms_failure -v
	@echo "‚úÖ Database chaos scenarios completed"

chaos-pms: ## Run PMS chaos scenarios (API failures, timeouts, rate limits)
	@echo "üå™Ô∏è  Running PMS chaos scenarios..."
	@poetry run python -m pytest tests/chaos/test_advanced_resilience.py::TestMTTRMetrics::test_pms_failure_mttr -v
	@echo "‚úÖ PMS chaos scenarios completed"

chaos-resource: ## Run resource chaos scenarios (memory pressure, CPU throttling)
	@echo "üå™Ô∏è  Running resource chaos scenarios..."
	@poetry run pytest tests/chaos/scenarios/test_resource.py -v || echo "‚ö†Ô∏è  Resource chaos scenarios require manual setup"
	@echo "‚úÖ Resource chaos scenarios completed"

chaos-all: ## Run all chaos scenarios sequentially
	@echo "üå™Ô∏è  Running ALL chaos scenarios..."
	@echo ""
	@echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
	@echo "Phase 1: Network Chaos"
	@echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
	@$(MAKE) chaos-network
	@sleep 15
	@echo ""
	@echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
	@echo "Phase 2: Service Chaos"
	@echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
	@$(MAKE) chaos-service
	@sleep 15
	@echo ""
	@echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
	@echo "Phase 3: Database Chaos"
	@echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
	@$(MAKE) chaos-database
	@sleep 15
	@echo ""
	@echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
	@echo "Phase 4: PMS Chaos"
	@echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
	@$(MAKE) chaos-pms
	@echo ""
	@echo "‚úÖ ALL chaos scenarios completed"
	@echo ""
	@echo "üìä Generate report: make chaos-report"

chaos-resilience: ## Run comprehensive resilience test suite
	@echo "üõ°Ô∏è  Running resilience test suite..."
	@poetry run python -m pytest tests/chaos/test_advanced_resilience.py -v
	@echo "‚úÖ Resilience tests completed"

chaos-report: ## Generate chaos experiment report
	@echo "üìä Generating chaos experiment report..."
	@mkdir -p .playbook/chaos_reports
	@echo "Chaos Engineering Report - $(shell date '+%Y-%m-%d %H:%M:%S')" > .playbook/chaos_reports/latest.txt
	@echo "=============================================" >> .playbook/chaos_reports/latest.txt
	@echo "" >> .playbook/chaos_reports/latest.txt
	@poetry run pytest tests/chaos/test_advanced_resilience.py -v --tb=short | tee -a .playbook/chaos_reports/latest.txt || true
	@echo "" >> .playbook/chaos_reports/latest.txt
	@echo "Report saved to: .playbook/chaos_reports/latest.txt"
	@echo "‚úÖ Chaos report generated"

chaos-monkey: ## Start Chaos Monkey (random fault injection) - USE WITH CAUTION
	@echo "‚ö†Ô∏è  WARNING: Starting Chaos Monkey!"
	@echo "‚ö†Ô∏è  This will randomly inject faults into the system."
	@echo "‚ö†Ô∏è  Press Ctrl+C to stop."
	@echo ""
	@read -p "Are you sure you want to continue? (yes/no): " confirm && \
	 if [ "$$confirm" = "yes" ]; then \
	   poetry run python -c "import asyncio; from tests.chaos.orchestrator import ChaosMonkey; monkey = ChaosMonkey(enabled=True, probability=0.1); monkey.start(); asyncio.get_event_loop().run_forever()"; \
	 else \
	   echo "Cancelled."; \
	 fi

chaos-dry-run: ## Run chaos experiments in dry-run mode (no actual injection)
	@echo "üß™ Running chaos experiments in DRY RUN mode..."
	@poetry run python -c "\
	import asyncio; \
	from tests.chaos.orchestrator import ChaosOrchestrator; \
	from tests.chaos.scenarios import network_scenarios; \
	async def run(): \
	    orchestrator = ChaosOrchestrator(); \
	    scenario = network_scenarios[0]; \
	    scenario.duration_seconds = 30; \
	    await orchestrator.run_experiment(scenario, dry_run=True); \
	asyncio.run(run()); \
	"
	@echo "‚úÖ Dry run completed (no actual faults injected)"


.DEFAULT_GOAL := help
