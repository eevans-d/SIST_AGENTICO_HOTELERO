groups:
  - name: agente-recording
    interval: 30s
    rules:
      - record: orchestrator_error_percentage
        expr: 100 * (sum by (intent) (rate(orchestrator_errors_total[5m])) / sum by (intent) (rate(orchestrator_messages_total[5m])))

      - record: orchestrator_latency_p95_seconds
        expr: histogram_quantile(0.95, sum by (le, intent) (rate(orchestrator_latency_seconds_bucket[5m])))

      - record: pms_api_latency_p95_seconds
        expr: histogram_quantile(0.95, sum by (le) (rate(pms_api_latency_seconds_bucket[5m])))

      - record: http_5xx_rate_by_endpoint
        expr: sum by (endpoint) (rate(http_requests_total{status_code=~"5.."}[5m]))

      - record: orchestrator_message_rate_by_intent_status
        expr: sum by (intent, status) (rate(orchestrator_messages_total[5m]))

      - record: orchestrator_success_rate
        expr: 100 * (sum by (intent) (rate(orchestrator_messages_total{status="ok"}[5m])) / sum by (intent) (rate(orchestrator_messages_total[5m])))

      - record: orchestrator_success_rate_all
        expr: 100 * (sum(rate(orchestrator_messages_total{status="ok"}[5m])) / sum(rate(orchestrator_messages_total[5m])))

      # Tasa global de mensajes del orquestador (para aplicar pisos de tráfico en alertas SLO)
      - record: orchestrator_message_rate_all
        expr: sum(rate(orchestrator_messages_total[5m]))

      # Error ratio (global) y burn rate basado en SLO_TARGET (error budget fraction)
      - record: orchestrator_error_ratio_5m
        expr: (sum(rate(orchestrator_messages_total{status!="ok"}[5m])) / sum(rate(orchestrator_messages_total[5m])))

      - record: orchestrator_error_ratio_1h
        expr: (sum(rate(orchestrator_messages_total{status!="ok"}[1h])) / sum(rate(orchestrator_messages_total[1h])))

      - record: orchestrator_error_ratio_30m
        expr: (sum(rate(orchestrator_messages_total{status!="ok"}[30m])) / sum(rate(orchestrator_messages_total[30m])))

      - record: orchestrator_error_ratio_6h
        expr: (sum(rate(orchestrator_messages_total{status!="ok"}[6h])) / sum(rate(orchestrator_messages_total[6h])))

      - record: orchestrator_burn_rate_fast
        expr: orchestrator_error_ratio_5m / BUDGET_FRACTION

      - record: orchestrator_burn_rate_slow
        expr: orchestrator_error_ratio_1h / BUDGET_FRACTION

      - record: orchestrator_burn_rate_fast2
        expr: orchestrator_error_ratio_30m / BUDGET_FRACTION

      - record: orchestrator_burn_rate_slow2
        expr: orchestrator_error_ratio_6h / BUDGET_FRACTION

      # Constantes de referencia (para paneles/dashboard)
      - record: orchestrator_slo_target
        expr: SLO_TARGET_VALUE

      - record: orchestrator_error_budget_fraction
        expr: BUDGET_FRACTION

      # Error budget consumption estimations
      - record: orchestrator_error_budget_used_ratio_30m
        expr: clamp_min(orchestrator_error_ratio_30m / BUDGET_FRACTION, 0)

      - record: orchestrator_error_budget_remaining_ratio_30m
        expr: clamp_max(1 - orchestrator_error_budget_used_ratio_30m, 1)

      # Estimación de horas hasta agotar presupuesto si se mantiene burn rate fast actual (>0)
      - record: orchestrator_error_budget_hours_to_exhaust_fast
        expr: clamp_min(( (1 - (orchestrator_error_ratio_5m / BUDGET_FRACTION)) / (orchestrator_burn_rate_fast) ) * 30*24, 0)

      # Estimación usando ventana lenta (1h/6h) para panorama más estable
      - record: orchestrator_error_budget_hours_to_exhaust_slow
        expr: clamp_min(( (1 - (orchestrator_error_ratio_1h / BUDGET_FRACTION)) / (orchestrator_burn_rate_slow) ) * 30*24, 0)

      # Piso de tráfico SLO parametrizable
      - record: orchestrator_slo_traffic_floor
        expr: TRAFFIC_FLOOR_VALUE

      # ------------------------------------------------------------------
      # PMS Cache Performance
      # Ratio de aciertos del cache (5m). Protegemos contra división por cero.
      - record: pms_cache_hit_ratio
        expr: sum(rate(pms_cache_hits_total[5m])) / clamp_min(sum(rate(pms_cache_hits_total[5m])) + sum(rate(pms_cache_misses_total[5m])), 0.000001)

      # ------------------------------------------------------------------
      # Circuit Breaker PMS Predictive Metrics
      # Ratio de fallos (ventanas múltiples) basado en llamadas envueltas
      - record: pms_cb_failure_ratio_1m
        expr: sum(rate(pms_circuit_breaker_calls_total{result="failure"}[1m])) / clamp_min(sum(rate(pms_circuit_breaker_calls_total[1m])), 0.000001)

      - record: pms_cb_failure_ratio_5m
        expr: sum(rate(pms_circuit_breaker_calls_total{result="failure"}[5m])) / clamp_min(sum(rate(pms_circuit_breaker_calls_total[5m])), 0.000001)

      - record: pms_cb_failure_ratio_15m
        expr: sum(rate(pms_circuit_breaker_calls_total{result="failure"}[15m])) / clamp_min(sum(rate(pms_circuit_breaker_calls_total[15m])), 0.000001)

      # Proporción de la racha actual vs umbral (0..1)
      - record: pms_cb_failure_streak_fraction
        expr: pms_circuit_breaker_failure_streak / 5  # 5 es failure_threshold actual

      # Velocidad de incremento de fallos (derivada 5m) - aproximación: incremento medio por minuto
      - record: pms_cb_failure_streak_rate
        expr: rate(pms_circuit_breaker_failure_streak[5m])

      # Estimación de minutos hasta apertura si la racha sigue creciendo (solo cuando >0)
      - record: pms_cb_minutes_to_open_estimate
        expr: clamp_min((5 - pms_circuit_breaker_failure_streak) / clamp_min(pms_cb_failure_streak_rate, 0.000001) / 60, 0)

      # Condición booleana (0/1) de riesgo de apertura: racha >=60% y failure_ratio_1m > 0.5
      - record: pms_cb_risk_imminent_raw
        expr: (pms_cb_failure_streak_fraction >= 0.6) * (pms_cb_failure_ratio_1m > 0.5)

      # Suavizado (promedio 3m) para evitar flapping del riesgo
      - record: pms_cb_risk_imminent
        expr: avg_over_time(pms_cb_risk_imminent_raw[3m])
