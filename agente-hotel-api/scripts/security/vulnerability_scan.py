#!/usr/bin/env python3
"""
P011: Dependency Vulnerability Scan
====================================

Escaneo exhaustivo de vulnerabilidades en dependencias Python.
Combina m√∫ltiples herramientas para detecci√≥n completa de CVEs.

Herramientas integradas:
- pip-audit: CVE database scanning (PyPI Advisory Database)
- safety: Safety DB vulnerability scanning
- pip list --outdated: Detecci√≥n de paquetes desactualizados
- licensecheck: Validaci√≥n de compatibilidad de licencias

Uso:
    python scripts/security/vulnerability_scan.py [--format json|html|markdown] [--output FILE]

Referencias:
- OWASP Dependency Check: https://owasp.org/www-project-dependency-check/
- NIST NVD: https://nvd.nist.gov/
"""

import argparse
import json
import subprocess
import sys
from dataclasses import asdict, dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional


@dataclass
class Vulnerability:
    """Representa una vulnerabilidad encontrada."""

    package: str
    installed_version: str
    vulnerability_id: str  # CVE-XXXX-XXXXX o GHSA-XXXX
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW
    affected_versions: str
    fixed_version: Optional[str]
    description: str
    advisory_url: Optional[str]
    source: str  # pip-audit, safety, manual


@dataclass
class OutdatedPackage:
    """Representa un paquete desactualizado."""

    package: str
    current_version: str
    latest_version: str
    package_type: str  # direct, transitive


@dataclass
class LicenseIssue:
    """Representa un problema de licencia."""

    package: str
    license: str
    issue_type: str  # incompatible, unknown, copyleft
    severity: str  # HIGH, MEDIUM, LOW
    recommendation: str


@dataclass
class ScanResult:
    """Resultado consolidado del escaneo."""

    scan_timestamp: str
    scan_duration_seconds: float
    vulnerabilities: List[Vulnerability]
    outdated_packages: List[OutdatedPackage]
    license_issues: List[LicenseIssue]
    summary: Dict[str, Any]


class VulnerabilityScanner:
    """Esc√°ner de vulnerabilidades en dependencias Python."""

    def __init__(self, project_root: Path):
        self.project_root = project_root
        self.pyproject_path = project_root / "pyproject.toml"
        self.requirements_path = project_root / "requirements.txt"

        # Licencias permitidas (compatibles con MIT/Apache 2.0)
        self.allowed_licenses = {
            "MIT",
            "Apache-2.0",
            "Apache 2.0",
            "BSD-3-Clause",
            "BSD-2-Clause",
            "ISC",
            "Python Software Foundation License",
            "PSF",
            "Unlicense",
            "Public Domain",
            "0BSD",
        }

        # Licencias copyleft (requieren revisi√≥n legal)
        self.copyleft_licenses = {
            "GPL-3.0",
            "GPL-2.0",
            "LGPL-3.0",
            "LGPL-2.1",
            "AGPL-3.0",
            "EPL-2.0",
            "MPL-2.0",
        }

    def run_pip_audit(self) -> List[Vulnerability]:
        """
        Ejecuta pip-audit para detectar vulnerabilidades conocidas.

        pip-audit consulta PyPI Advisory Database y OSV.
        """
        print("üîç Ejecutando pip-audit...")
        vulnerabilities = []

        try:
            result = subprocess.run(
                ["pip-audit", "--format", "json", "--desc", "on"],
                capture_output=True,
                text=True,
                timeout=300,
            )

            if result.returncode == 0:
                data = json.loads(result.stdout)
                for vuln in data.get("vulnerabilities", []):
                    vulnerabilities.append(
                        Vulnerability(
                            package=vuln["name"],
                            installed_version=vuln["version"],
                            vulnerability_id=vuln["id"],
                            severity=self._normalize_severity(vuln.get("severity", "UNKNOWN")),
                            affected_versions=vuln.get("affected_versions", "N/A"),
                            fixed_version=vuln.get("fix_versions", [None])[0],
                            description=vuln.get("description", "No description available"),
                            advisory_url=vuln.get("advisory_url"),
                            source="pip-audit",
                        )
                    )
                print(f"   ‚úì pip-audit: {len(vulnerabilities)} vulnerabilidades encontradas")
            elif "No known vulnerabilities found" in result.stdout:
                print("   ‚úì pip-audit: No se encontraron vulnerabilidades")
            else:
                print(f"   ‚ö† pip-audit retorn√≥ c√≥digo {result.returncode}")
                print(f"   Stderr: {result.stderr}")

        except FileNotFoundError:
            print("   ‚ö† pip-audit no est√° instalado. Instalar con: pip install pip-audit")
        except subprocess.TimeoutExpired:
            print("   ‚ö† pip-audit timeout (>5min)")
        except Exception as e:
            print(f"   ‚ö† Error ejecutando pip-audit: {e}")

        return vulnerabilities

    def run_safety_check(self) -> List[Vulnerability]:
        """
        Ejecuta safety check para detectar vulnerabilidades conocidas.

        safety usa Safety DB (requiere API key para full DB).
        """
        print("üîç Ejecutando safety check...")
        vulnerabilities = []

        try:
            result = subprocess.run(
                ["safety", "check", "--json", "--bare"],
                capture_output=True,
                text=True,
                timeout=180,
            )

            if result.stdout.strip():
                try:
                    data = json.loads(result.stdout)
                    for vuln in data:
                        vulnerabilities.append(
                            Vulnerability(
                                package=vuln[0],
                                installed_version=vuln[2],
                                vulnerability_id=vuln[4] if len(vuln) > 4 else "SAFETY-UNKNOWN",
                                severity=self._infer_severity_from_description(vuln[3]),
                                affected_versions=f"<{vuln[1]}",
                                fixed_version=vuln[1],
                                description=vuln[3],
                                advisory_url=None,
                                source="safety",
                            )
                        )
                    print(f"   ‚úì safety: {len(vulnerabilities)} vulnerabilidades encontradas")
                except json.JSONDecodeError:
                    print("   ‚ö† safety: No se pudo parsear JSON")
            else:
                print("   ‚úì safety: No se encontraron vulnerabilidades")

        except FileNotFoundError:
            print("   ‚ö† safety no est√° instalado. Instalar con: pip install safety")
        except subprocess.TimeoutExpired:
            print("   ‚ö† safety timeout (>3min)")
        except Exception as e:
            print(f"   ‚ö† Error ejecutando safety: {e}")

        return vulnerabilities

    def check_outdated_packages(self) -> List[OutdatedPackage]:
        """
        Detecta paquetes desactualizados usando pip list --outdated.
        """
        print("üîç Verificando paquetes desactualizados...")
        outdated = []

        try:
            result = subprocess.run(
                ["pip", "list", "--outdated", "--format", "json"],
                capture_output=True,
                text=True,
                timeout=120,
            )

            if result.returncode == 0:
                data = json.loads(result.stdout)
                for pkg in data:
                    outdated.append(
                        OutdatedPackage(
                            package=pkg["name"],
                            current_version=pkg["version"],
                            latest_version=pkg["latest_version"],
                            package_type=pkg.get("type", "unknown"),
                        )
                    )
                print(f"   ‚úì pip list: {len(outdated)} paquetes desactualizados")
            else:
                print(f"   ‚ö† pip list retorn√≥ c√≥digo {result.returncode}")

        except Exception as e:
            print(f"   ‚ö† Error verificando paquetes desactualizados: {e}")

        return outdated

    def check_licenses(self) -> List[LicenseIssue]:
        """
        Verifica compatibilidad de licencias de dependencias.

        Usa pip-licenses para obtener informaci√≥n de licencias.
        """
        print("üîç Verificando licencias de dependencias...")
        license_issues = []

        try:
            result = subprocess.run(
                ["pip-licenses", "--format", "json", "--with-urls"],
                capture_output=True,
                text=True,
                timeout=60,
            )

            if result.returncode == 0:
                data = json.loads(result.stdout)
                for pkg in data:
                    license_name = pkg.get("License", "UNKNOWN")
                    package_name = pkg.get("Name", "unknown")

                    # Licencia desconocida
                    if license_name in ["UNKNOWN", "UNKNOWN LICENSE", ""]:
                        license_issues.append(
                            LicenseIssue(
                                package=package_name,
                                license=license_name,
                                issue_type="unknown",
                                severity="MEDIUM",
                                recommendation=f"Verificar licencia manualmente en {pkg.get('URL', 'PyPI')}",
                            )
                        )

                    # Licencia copyleft
                    elif any(copyleft in license_name for copyleft in self.copyleft_licenses):
                        license_issues.append(
                            LicenseIssue(
                                package=package_name,
                                license=license_name,
                                issue_type="copyleft",
                                severity="HIGH",
                                recommendation="Requiere revisi√≥n legal. Considerar alternativa con licencia permisiva.",
                            )
                        )

                    # Licencia no permitida
                    elif not any(allowed in license_name for allowed in self.allowed_licenses):
                        # Excepciones comunes
                        if "BSD" in license_name or "MIT" in license_name or "Apache" in license_name:
                            continue

                        license_issues.append(
                            LicenseIssue(
                                package=package_name,
                                license=license_name,
                                issue_type="incompatible",
                                severity="LOW",
                                recommendation=f"Verificar compatibilidad de licencia '{license_name}' con proyecto MIT/Apache 2.0",
                            )
                        )

                print(f"   ‚úì pip-licenses: {len(license_issues)} problemas de licencia encontrados")
            else:
                print(f"   ‚ö† pip-licenses retorn√≥ c√≥digo {result.returncode}")

        except FileNotFoundError:
            print("   ‚ö† pip-licenses no est√° instalado. Instalar con: pip install pip-licenses")
        except Exception as e:
            print(f"   ‚ö† Error verificando licencias: {e}")

        return license_issues

    def run_full_scan(self) -> ScanResult:
        """
        Ejecuta escaneo completo de seguridad de dependencias.
        """
        print("=" * 80)
        print("üîê ESCANEO DE SEGURIDAD DE DEPENDENCIAS - P011")
        print("=" * 80)
        print()

        start_time = datetime.now()

        # Ejecutar todos los escaneos
        pip_audit_vulns = self.run_pip_audit()
        safety_vulns = self.run_safety_check()
        outdated = self.check_outdated_packages()
        license_issues = self.check_licenses()

        # Consolidar vulnerabilidades (deduplicar por package + vuln_id)
        all_vulns = pip_audit_vulns + safety_vulns
        unique_vulns = {}
        for v in all_vulns:
            key = f"{v.package}:{v.vulnerability_id}"
            if key not in unique_vulns:
                unique_vulns[key] = v
            else:
                # Preferir pip-audit sobre safety (m√°s detallado)
                if v.source == "pip-audit":
                    unique_vulns[key] = v

        vulnerabilities = list(unique_vulns.values())

        # Calcular resumen
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()

        severity_counts = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "UNKNOWN": 0}
        for v in vulnerabilities:
            severity_counts[v.severity] = severity_counts.get(v.severity, 0) + 1

        summary = {
            "total_vulnerabilities": len(vulnerabilities),
            "severity_breakdown": severity_counts,
            "critical_high_count": severity_counts["CRITICAL"] + severity_counts["HIGH"],
            "total_outdated_packages": len(outdated),
            "total_license_issues": len(license_issues),
            "scan_status": self._determine_scan_status(severity_counts, license_issues),
            "recommendations": self._generate_recommendations(vulnerabilities, outdated, license_issues),
        }

        result = ScanResult(
            scan_timestamp=start_time.isoformat(),
            scan_duration_seconds=duration,
            vulnerabilities=vulnerabilities,
            outdated_packages=outdated,
            license_issues=license_issues,
            summary=summary,
        )

        self._print_summary(result)

        return result

    def _normalize_severity(self, severity: str) -> str:
        """Normaliza niveles de severidad."""
        severity_upper = severity.upper()
        if severity_upper in ["CRITICAL", "HIGH", "MEDIUM", "LOW"]:
            return severity_upper
        return "UNKNOWN"

    def _infer_severity_from_description(self, description: str) -> str:
        """Infiere severidad de la descripci√≥n (safety no siempre provee severity)."""
        desc_lower = description.lower()
        if any(word in desc_lower for word in ["critical", "remote code execution", "rce", "arbitrary code"]):
            return "CRITICAL"
        elif any(word in desc_lower for word in ["high", "sql injection", "xss", "authentication"]):
            return "HIGH"
        elif any(word in desc_lower for word in ["medium", "denial of service", "dos"]):
            return "MEDIUM"
        else:
            return "LOW"

    def _determine_scan_status(self, severity_counts: Dict[str, int], license_issues: List[LicenseIssue]) -> str:
        """Determina el estado general del escaneo."""
        if severity_counts["CRITICAL"] > 0:
            return "CRITICAL - Acci√≥n inmediata requerida"
        elif severity_counts["HIGH"] > 0:
            return "HIGH - Requiere atenci√≥n prioritaria"
        elif any(issue.severity == "HIGH" for issue in license_issues):
            return "HIGH - Problemas de licencia cr√≠ticos"
        elif severity_counts["MEDIUM"] > 0 or len(license_issues) > 0:
            return "MEDIUM - Revisi√≥n recomendada"
        elif severity_counts["LOW"] > 0:
            return "LOW - Problemas menores detectados"
        else:
            return "PASS - No se encontraron problemas cr√≠ticos"

    def _generate_recommendations(
        self, vulnerabilities: List[Vulnerability], outdated: List[OutdatedPackage], license_issues: List[LicenseIssue]
    ) -> List[str]:
        """Genera recomendaciones basadas en hallazgos."""
        recommendations = []

        critical_high = [v for v in vulnerabilities if v.severity in ["CRITICAL", "HIGH"]]
        if critical_high:
            recommendations.append(
                f"üî¥ URGENTE: Actualizar {len(critical_high)} paquetes con vulnerabilidades CRITICAL/HIGH"
            )

            # Agrupar por paquete
            packages_to_update = {}
            for v in critical_high:
                if v.package not in packages_to_update:
                    packages_to_update[v.package] = []
                packages_to_update[v.package].append(v)

            for pkg, vulns in packages_to_update.items():
                fixed_versions = [v.fixed_version for v in vulns if v.fixed_version]
                if fixed_versions:
                    recommendations.append(f"   ‚Ä¢ {pkg}: Actualizar a versi√≥n {max(fixed_versions)}")

        if len(outdated) > 10:
            recommendations.append(
                f"üü° Actualizar {len(outdated)} paquetes desactualizados (comando: pip list --outdated)"
            )

        copyleft_issues = [issue for issue in license_issues if issue.issue_type == "copyleft"]
        if copyleft_issues:
            recommendations.append(
                f"‚öñÔ∏è Revisar {len(copyleft_issues)} paquetes con licencias copyleft (requiere revisi√≥n legal)"
            )

        if not recommendations:
            recommendations.append("‚úÖ Todas las dependencias est√°n actualizadas y sin vulnerabilidades conocidas")

        return recommendations

    def _print_summary(self, result: ScanResult):
        """Imprime resumen del escaneo en consola."""
        print()
        print("=" * 80)
        print("üìä RESUMEN DEL ESCANEO")
        print("=" * 80)
        print()
        print(f"‚è±Ô∏è  Duraci√≥n: {result.scan_duration_seconds:.2f}s")
        print(f"üìÖ Timestamp: {result.scan_timestamp}")
        print()
        print(f"üêõ Vulnerabilidades encontradas: {result.summary['total_vulnerabilities']}")
        print(f"   ‚Ä¢ CRITICAL: {result.summary['severity_breakdown']['CRITICAL']}")
        print(f"   ‚Ä¢ HIGH:     {result.summary['severity_breakdown']['HIGH']}")
        print(f"   ‚Ä¢ MEDIUM:   {result.summary['severity_breakdown']['MEDIUM']}")
        print(f"   ‚Ä¢ LOW:      {result.summary['severity_breakdown']['LOW']}")
        print()
        print(f"üì¶ Paquetes desactualizados: {result.summary['total_outdated_packages']}")
        print(f"‚öñÔ∏è  Problemas de licencia: {result.summary['total_license_issues']}")
        print()
        print(f"üéØ Estado: {result.summary['scan_status']}")
        print()

        if result.summary["recommendations"]:
            print("üí° RECOMENDACIONES:")
            print()
            for rec in result.summary["recommendations"]:
                print(f"   {rec}")
            print()

        print("=" * 80)

    def export_to_json(self, result: ScanResult, output_path: Path):
        """Exporta resultado a JSON."""
        data = {
            "scan_timestamp": result.scan_timestamp,
            "scan_duration_seconds": result.scan_duration_seconds,
            "vulnerabilities": [asdict(v) for v in result.vulnerabilities],
            "outdated_packages": [asdict(p) for p in result.outdated_packages],
            "license_issues": [asdict(i) for i in result.license_issues],
            "summary": result.summary,
        }

        output_path.write_text(json.dumps(data, indent=2, ensure_ascii=False))
        print(f"‚úÖ Reporte JSON exportado a: {output_path}")

    def export_to_html(self, result: ScanResult, output_path: Path):
        """Exporta resultado a HTML."""
        html = self._generate_html_report(result)
        output_path.write_text(html)
        print(f"‚úÖ Reporte HTML exportado a: {output_path}")

    def export_to_markdown(self, result: ScanResult, output_path: Path):
        """Exporta resultado a Markdown."""
        md = self._generate_markdown_report(result)
        output_path.write_text(md)
        print(f"‚úÖ Reporte Markdown exportado a: {output_path}")

    def _generate_html_report(self, result: ScanResult) -> str:
        """Genera reporte HTML."""
        html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Reporte de Seguridad - P011</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        h1 {{ color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }}
        h2 {{ color: #34495e; margin-top: 30px; }}
        .summary {{ background: #ecf0f1; padding: 20px; border-radius: 5px; margin: 20px 0; }}
        .critical {{ background: #e74c3c; color: white; padding: 5px 10px; border-radius: 3px; }}
        .high {{ background: #e67e22; color: white; padding: 5px 10px; border-radius: 3px; }}
        .medium {{ background: #f39c12; color: white; padding: 5px 10px; border-radius: 3px; }}
        .low {{ background: #95a5a6; color: white; padding: 5px 10px; border-radius: 3px; }}
        table {{ width: 100%; border-collapse: collapse; margin: 20px 0; }}
        th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background: #3498db; color: white; }}
        tr:hover {{ background: #f5f5f5; }}
        .recommendations {{ background: #d5f4e6; padding: 15px; border-left: 4px solid #27ae60; margin: 20px 0; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê Reporte de Seguridad de Dependencias - P011</h1>

        <div class="summary">
            <h2>üìä Resumen Ejecutivo</h2>
            <p><strong>Fecha:</strong> {result.scan_timestamp}</p>
            <p><strong>Duraci√≥n:</strong> {result.scan_duration_seconds:.2f} segundos</p>
            <p><strong>Estado:</strong> {result.summary["scan_status"]}</p>

            <h3>M√©tricas</h3>
            <ul>
                <li><strong>Total vulnerabilidades:</strong> {result.summary["total_vulnerabilities"]}</li>
                <li>
                    <span class="critical">CRITICAL: {result.summary["severity_breakdown"]["CRITICAL"]}</span>
                    <span class="high">HIGH: {result.summary["severity_breakdown"]["HIGH"]}</span>
                    <span class="medium">MEDIUM: {result.summary["severity_breakdown"]["MEDIUM"]}</span>
                    <span class="low">LOW: {result.summary["severity_breakdown"]["LOW"]}</span>
                </li>
                <li><strong>Paquetes desactualizados:</strong> {result.summary["total_outdated_packages"]}</li>
                <li><strong>Problemas de licencia:</strong> {result.summary["total_license_issues"]}</li>
            </ul>
        </div>

        {self._html_vulnerabilities_section(result.vulnerabilities)}
        {self._html_outdated_section(result.outdated_packages)}
        {self._html_licenses_section(result.license_issues)}
        {self._html_recommendations_section(result.summary["recommendations"])}
    </div>
</body>
</html>"""
        return html

    def _html_vulnerabilities_section(self, vulnerabilities: List[Vulnerability]) -> str:
        if not vulnerabilities:
            return "<h2>‚úÖ No se encontraron vulnerabilidades</h2>"

        rows = ""
        for v in sorted(vulnerabilities, key=lambda x: ("CRITICAL", "HIGH", "MEDIUM", "LOW").index(x.severity)):
            advisory_link = f'<a href="{v.advisory_url}" target="_blank">Link</a>' if v.advisory_url else "N/A"
            rows += f"""
            <tr>
                <td>{v.package}</td>
                <td>{v.installed_version}</td>
                <td><span class="{v.severity.lower()}">{v.severity}</span></td>
                <td>{v.vulnerability_id}</td>
                <td>{v.fixed_version or "N/A"}</td>
                <td>{v.description[:100]}...</td>
                <td>{advisory_link}</td>
            </tr>
            """

        return f"""
        <h2>üêõ Vulnerabilidades Detectadas ({len(vulnerabilities)})</h2>
        <table>
            <thead>
                <tr>
                    <th>Paquete</th>
                    <th>Versi√≥n</th>
                    <th>Severidad</th>
                    <th>ID</th>
                    <th>Fix</th>
                    <th>Descripci√≥n</th>
                    <th>Advisory</th>
                </tr>
            </thead>
            <tbody>
                {rows}
            </tbody>
        </table>
        """

    def _html_outdated_section(self, outdated: List[OutdatedPackage]) -> str:
        if not outdated:
            return "<h2>‚úÖ Todos los paquetes est√°n actualizados</h2>"

        rows = ""
        for pkg in sorted(outdated, key=lambda x: x.package):
            rows += f"""
            <tr>
                <td>{pkg.package}</td>
                <td>{pkg.current_version}</td>
                <td>{pkg.latest_version}</td>
                <td>{pkg.package_type}</td>
            </tr>
            """

        return f"""
        <h2>üì¶ Paquetes Desactualizados ({len(outdated)})</h2>
        <table>
            <thead>
                <tr>
                    <th>Paquete</th>
                    <th>Versi√≥n Actual</th>
                    <th>√öltima Versi√≥n</th>
                    <th>Tipo</th>
                </tr>
            </thead>
            <tbody>
                {rows}
            </tbody>
        </table>
        """

    def _html_licenses_section(self, license_issues: List[LicenseIssue]) -> str:
        if not license_issues:
            return "<h2>‚úÖ No se encontraron problemas de licencia</h2>"

        rows = ""
        for issue in sorted(license_issues, key=lambda x: ("HIGH", "MEDIUM", "LOW").index(x.severity)):
            rows += f"""
            <tr>
                <td>{issue.package}</td>
                <td>{issue.license}</td>
                <td>{issue.issue_type}</td>
                <td><span class="{issue.severity.lower()}">{issue.severity}</span></td>
                <td>{issue.recommendation}</td>
            </tr>
            """

        return f"""
        <h2>‚öñÔ∏è  Problemas de Licencia ({len(license_issues)})</h2>
        <table>
            <thead>
                <tr>
                    <th>Paquete</th>
                    <th>Licencia</th>
                    <th>Tipo de Problema</th>
                    <th>Severidad</th>
                    <th>Recomendaci√≥n</th>
                </tr>
            </thead>
            <tbody>
                {rows}
            </tbody>
        </table>
        """

    def _html_recommendations_section(self, recommendations: List[str]) -> str:
        items = "\n".join([f"<li>{rec}</li>" for rec in recommendations])
        return f"""
        <div class="recommendations">
            <h2>üí° Recomendaciones</h2>
            <ul>
                {items}
            </ul>
        </div>
        """

    def _generate_markdown_report(self, result: ScanResult) -> str:
        """Genera reporte Markdown."""
        md = f"""# üîê Reporte de Seguridad de Dependencias - P011

## üìä Resumen Ejecutivo

- **Fecha:** {result.scan_timestamp}
- **Duraci√≥n:** {result.scan_duration_seconds:.2f} segundos
- **Estado:** {result.summary["scan_status"]}

### M√©tricas

| M√©trica | Valor |
|---------|-------|
| Total vulnerabilidades | {result.summary["total_vulnerabilities"]} |
| CRITICAL | {result.summary["severity_breakdown"]["CRITICAL"]} |
| HIGH | {result.summary["severity_breakdown"]["HIGH"]} |
| MEDIUM | {result.summary["severity_breakdown"]["MEDIUM"]} |
| LOW | {result.summary["severity_breakdown"]["LOW"]} |
| Paquetes desactualizados | {result.summary["total_outdated_packages"]} |
| Problemas de licencia | {result.summary["total_license_issues"]} |

---

{self._md_vulnerabilities_section(result.vulnerabilities)}

{self._md_outdated_section(result.outdated_packages)}

{self._md_licenses_section(result.license_issues)}

{self._md_recommendations_section(result.summary["recommendations"])}
"""
        return md

    def _md_vulnerabilities_section(self, vulnerabilities: List[Vulnerability]) -> str:
        if not vulnerabilities:
            return "## ‚úÖ No se encontraron vulnerabilidades\n"

        rows = []
        for v in sorted(vulnerabilities, key=lambda x: ("CRITICAL", "HIGH", "MEDIUM", "LOW").index(x.severity)):
            advisory = f"[Link]({v.advisory_url})" if v.advisory_url else "N/A"
            rows.append(
                f"| {v.package} | {v.installed_version} | **{v.severity}** | {v.vulnerability_id} | {v.fixed_version or 'N/A'} | {v.description[:80]}... | {advisory} |"
            )

        table = "\n".join(rows)
        return f"""## üêõ Vulnerabilidades Detectadas ({len(vulnerabilities)})

| Paquete | Versi√≥n | Severidad | ID | Fix | Descripci√≥n | Advisory |
|---------|---------|-----------|----|----|-------------|----------|
{table}
"""

    def _md_outdated_section(self, outdated: List[OutdatedPackage]) -> str:
        if not outdated:
            return "## ‚úÖ Todos los paquetes est√°n actualizados\n"

        rows = []
        for pkg in sorted(outdated, key=lambda x: x.package):
            rows.append(f"| {pkg.package} | {pkg.current_version} | {pkg.latest_version} | {pkg.package_type} |")

        table = "\n".join(rows)
        return f"""## üì¶ Paquetes Desactualizados ({len(outdated)})

| Paquete | Versi√≥n Actual | √öltima Versi√≥n | Tipo |
|---------|----------------|----------------|------|
{table}
"""

    def _md_licenses_section(self, license_issues: List[LicenseIssue]) -> str:
        if not license_issues:
            return "## ‚úÖ No se encontraron problemas de licencia\n"

        rows = []
        for issue in sorted(license_issues, key=lambda x: ("HIGH", "MEDIUM", "LOW").index(x.severity)):
            rows.append(
                f"| {issue.package} | {issue.license} | {issue.issue_type} | **{issue.severity}** | {issue.recommendation} |"
            )

        table = "\n".join(rows)
        return f"""## ‚öñÔ∏è  Problemas de Licencia ({len(license_issues)})

| Paquete | Licencia | Tipo de Problema | Severidad | Recomendaci√≥n |
|---------|----------|------------------|-----------|---------------|
{table}
"""

    def _md_recommendations_section(self, recommendations: List[str]) -> str:
        items = "\n".join([f"- {rec}" for rec in recommendations])
        return f"""## üí° Recomendaciones

{items}
"""


def main():
    parser = argparse.ArgumentParser(description="P011: Dependency Vulnerability Scan")
    parser.add_argument(
        "--format",
        choices=["json", "html", "markdown"],
        default="json",
        help="Formato de salida del reporte (default: json)",
    )
    parser.add_argument(
        "--output", type=Path, help="Archivo de salida (default: .security/vuln-scan-{timestamp}.{ext})"
    )

    args = parser.parse_args()

    # Determinar project root
    project_root = Path(__file__).parent.parent.parent

    # Crear directorio de salida
    output_dir = project_root / ".security"
    output_dir.mkdir(exist_ok=True)

    # Ejecutar escaneo
    scanner = VulnerabilityScanner(project_root)
    result = scanner.run_full_scan()

    # Exportar resultado
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    if args.output:
        output_path = args.output
    else:
        ext = args.format if args.format != "markdown" else "md"
        output_path = output_dir / f"vuln-scan-{timestamp}.{ext}"

    if args.format == "json":
        scanner.export_to_json(result, output_path)
    elif args.format == "html":
        scanner.export_to_html(result, output_path)
    elif args.format == "markdown":
        scanner.export_to_markdown(result, output_path)

    # Exit code basado en severidad
    if result.summary["severity_breakdown"]["CRITICAL"] > 0:
        sys.exit(2)  # Critical vulnerabilities
    elif result.summary["severity_breakdown"]["HIGH"] > 0:
        sys.exit(1)  # High vulnerabilities
    else:
        sys.exit(0)  # Success


if __name__ == "__main__":
    main()
